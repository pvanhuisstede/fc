[
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "Tests (Fastcore)",
    "section": "",
    "text": "We can use args and kwargs to the function to check if it fails with special inputs:\n\n\n\n\ntest([1,2],[1,2], operator.eq)\ntest_fail(lambda: test([1,2],[1], operator.eq))\ntest([1,2],[1], operator.ne)\ntest_fail(lambda: test([1,2],[1,2], operator.ne))\n\n\n\n\n\n\n\n\n\n all_equal (a, b)\n\nCompares whether a and b are the same length and have the same contents\n\nall_equal(['abcd'],['abcd'])\ntest(['abcd'],['abcd'], all_equal)\n\n\n\n\n\n\n\n\n\n equals (a, b)\n\nCompares a and b for equality; supports sublists, tensors and arrays too\n\ntest([['abc'], ['a']], [['abc'], ['a']], equals)\n\n\n\n\n\n\n\n\n\n nequals (a, b)\n\nCompares a and b for not equals\n\ntest(['abc'], ['ab'], nequals)\n\n\n\n\n\n\n\n\n\n test_eq (a, b)\n\ntest that a==b\n\ntest_eq([1,2],[1,2])\ntest_eq([1,2], map(int,[1,2]))\ntest_eq(array([1,2]), array([1,2]))\ntest_eq([array([1,2]),3], [array([1,2]),3])\ntest_eq(dict(a=1,b=2), dict(b=2,a=1))\ntest_fail(lambda: test_eq([1,2], 1), contains=\"==\")\ntest_fail(lambda: test_eq(None, np.array([1,2])), contains=\"==\")\ntest_eq({'a', 'b', 'c'}, {'c', 'a', 'b'})\n\n\nimport pandas as pd\n\ndf1 = pd.DataFrame(dict(a=[1,2],b=['a','b']))\ndf2 = pd.DataFrame(dict(a=[1,2],b=['a','b']))\ndf3 = pd.DataFrame(dict(a=[1,2],b=['a','c']))\n\ntest_eq(df1, df2)\ntest_eq(df1.a, df2.a)\ntest_fail(lambda: test_eq(df1, df3), contains='==') # fails without the contains clause because the df's are NOT the same\nclass T(pd.Series): pass\ntest_eq(df1.iloc[0], T(df2.iloc[0]))\n\n\nimport torch\n\ntest_eq(torch.zeros(10), torch.zeros(10, dtype=torch.float64))\ntest_eq(torch.zeros(10), torch.ones(10)-1)\ntest_fail(lambda:test_eq(torch.zeros(10), torch.ones(1, 10)), contains='==')\ntest_eq(torch.zeros(3), [0,0,0])\n\n\n\n\n\n\n\n\n\n test_eq_type (a, b)\n\ntest that a==b and are same type\n\ntest_eq_type(1,1)\ntest_fail(lambda: test_eq_type(1,1.0))\ntest_eq_type([1,1],[1,1])\ntest_fail(lambda: test_eq_type([1,1],[1,1.0]))\ntest_fail(lambda: test_eq_type([1,1],(1,1)))\n\n\n\n\n\n\n\n\n\n test_ne (a, b)\n\ntest that a!=b\n\ntest_ne([1,2],[1])\ntest_ne([1,2],[1,3])\ntest_ne(array([1,2]),array([1,1]))\ntest_ne(array([1,2]),array([1,1]))\ntest_ne([array([1,2]),3],[array([1,2])])\ntest_ne([3,4],array([3]))\ntest_ne([3,4],array([3,5]))\ntest_ne(dict(a=1,b=2), ['a', 'b'])\ntest_ne(['a', 'b'], dict(a=1,b=2))\n\n\n\n\n\n\n\n\n\n is_close (a, b, eps=1e-05)\n\nIs a within eps of b\n\nis_close(1.23, 1.25, eps=0.1)\n\nTrue\n\n\n\n\n\n\n\n\n\n\n test_close (a, b, eps=1e-05)\n\ntest that a is within eps of b\n\ntest_close(1,1.001,eps=1e-2)\ntest_fail(lambda: test_close(1,1.001))\ntest_close([-0.001,1.001], [0.,1.], eps=1e-2)\ntest_close(np.array([-0.001,1.001]), np.array([0.,1.]), eps=1e-2)\ntest_close(array([-0.001,1.001]), array([0.,1.]), eps=1e-2)\n\n\n\n\n\n\n\n\n\n test_is (a, b)\n\ntest that a is b\n\ntest_fail(lambda: test_is([1], [1]))\na = [1]\ntest_is(a, a)\n\n\n\n\n\n\n\n\n\n test_shuffled (a, b)\n\ntest that a and b are shuffled versions of the same sequence of items\n\na = list(range(50))\nb = copy(a)\nrandom.shuffle(b)\ntest_shuffled(a,b)\ntest_fail(lambda: test_shuffled(a,a))\n\n\na = 'abc'\nb = 'abcabc'\ntest_fail(lambda:test_shuffled(a,b))\n\n\na = ['a', 42, True] \nb = [42, True, 'a']\ntest_shuffled(a,b)\n\n\n\n\n\n\n\n\n\n test_stdout (f, exp, regex=False)\n\nTest that f prints exp to stdout, optionally checking as regex\n\ntest_stdout(lambda: print('hi'), 'hi')\ntest_fail(lambda: test_stdout(lambda: print('hi'), 'ho'))\ntest_stdout(lambda: 1+1, '')\ntest_stdout(lambda: print('hi there!'), r'^hi.*!$', regex=True)\n\n\n\n\n\n\n\n\n\n test_warns (f, show=False)\n\n\ntest_warns(lambda: warnings.warn(\"Oh no!\"), {})\ntest_fail(lambda: test_warns(lambda: 2+2))\n\n\ntest_warns(lambda: warnings.warn(\"Oh no!\"), show=True)\n\n<class 'UserWarning'>: Oh no!\n\n\n\n\n\n\n\n\n\n\n\n ExceptionExpected (ex=<class'Exception'>, regex='')\n\nContext manager that tests if an exception is raised\n\ndef _tst_1(): assert False, \"This is a test\"\ndef _tst_2(): raise SyntaxError\n\nwith ExceptionExpected(): _tst_1()\nwith ExceptionExpected(ex=AssertionError, regex=\"This is a test\"): _tst_1()\nwith ExceptionExpected(ex=SyntaxError): _tst_2()\n\nexception is short for ExceptionExpected():\n\nwith exception: _tst_1()\n\n\n\nReturn the attribute attr for object o. If the attribute does not exist, then return the object o instead.\n\n\n\nIn types which provide rich display functionality in Jupyter, their repr is also called in order to provide a fallback text representation. Unfortunately, this includes a memory address which changes on every invocation, making it non-deterministic. This causes diffs to get messy and creates conflicts in git. To fix this, put repr=basic_repr() inside your class.\n\n\n\n\n\n basic_repr (flds=None)\n\nMinimal __repr__\n\nclass SomeClass: __repr__=basic_repr()\nrepr(SomeClass())\n\n'<__main__.SomeClass>'\n\n\nIf you pass in a list of attributes (flds) of an object, then this will generate a string with the name of each attribute and ist corresponding value. The format of this string is key=value, with key being the name of the attribute, and value the value of the attribute.\nWhen possible name attribute is used, othetwise the value’s __repr__ string.\n\nclass SomeClass:\n    a=1\n    b='foo'\n    __repr__=basic_repr('a,b')\n    __name__='some-class'\n\nrepr(SomeClass())\n\n\"__main__.SomeClass(a=1, b='foo')\""
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Exploring fastcore library",
    "section": "",
    "text": "00_tests.ipynb\n01_basics.ipynb"
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Basics (Fastcore)",
    "section": "",
    "text": "ifnone is a function that takes care of the pattern b if a is None else a. But ifnone evaluates both a and b, whereas with the if function this is not the case.\n\n\nReturn the attribute attr for object o. If the attribute does not exist, then return the object o instead.\n\n\n\n\n\n maybe_attr (o, attr)\n\ngetattr(o,attr,o)\n\nclass myobj: myattr='foo'\n\ntest_eq(maybe_attr(myobj, 'myattr'), 'foo')\ntest_eq(maybe_attr(myobj, 'another_attr'), myobj)\n\n\n\n\n\n\n\n\n\n basic_repr (flds=None)\n\nMinimal __repr__\nThe issue here is that types in Jupyter with rich display functionality can be represented using __repr__ to provide a text representation, but due to changing memory addresses being displayed, conflicts are many.\nTo fix this behaviour, put __repr__=basic_repr() inside your class.\n\nclass SomeClass: __repr__=basic_repr()\nrepr(SomeClass())\n\n'<__main__.SomeClass>'\n\n\nAs we can infer from the basic_repr documentation, we can pass in flds attributes. Then a string is generated in the k=v format, first using the __name__ attribute, otherwise using __repr__ as fallback for string construction.\n\nclass SomeClass:\n  a=1\n  b='foo'\n  __repr__=basic_repr('a,b')\n  __name__='some-class'\n\nrepr(SomeClass)\n\n\"<class '__main__.SomeClass'>\"\n\n\n\n\n\n\n\n\n\n\n is_array (x)\n\nTrue if x supports __array__ or iloc\n\nis_array(np.array(1)), is_array([1])\n\n(True, False)\n\n\n\n\n\n\n\n\n\n\n listify (o=None, *rest, use_list=False, match=None)\n\nConvert o to a list\nThe conversion is meant to do ‘what the caller of the function is expecting it to do’.\n\ntest_eq(listify('hi'), ['hi'])\ntest_eq(listify(array(1)), [array(1)])\ntest_eq(listify(1), [1])\ntest_eq(listify([1,2]), [1,2])\ntest_eq(listify(range(3)), [0,1,2])\ntest_eq(listify(None), [])\ntest_eq(listify(1,2), [1,2])\n\n\narr = np.arange(9).reshape(3,3)\nlistify(arr)\n\n[array([[0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8]])]\n\n\n\nlistify(array([1,2]))\n\n[array([1, 2])]\n\n\nGenerators are turned into lists also:\n\ngen = (o for o in range(3))\ntest_eq(listify(gen), [0, 1, 2])\n\nWe can use match to provide a length to match:\n\ntest_eq(listify(1,match=3), [1,1,1])\n\nIf match is a sequence, it’s length is used:\n\ntest_eq(listify(1,match=range(3)), [1,1,1])\n\nIf the listified item is not of length 1, it must be the same length as match:\n\ntest_eq(listify([1,1,1], match=3), [1,1,1])\ntest_fail(lambda: listify([1,1], match=3))"
  }
]